package rln

import (
	"bytes"
	"fmt"
	"math/big"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestBigInt(t *testing.T) {
	base := big.NewInt(2)
	value := base.Exp(base, big.NewInt(248), nil)
	value = value.Sub(value, big.NewInt(1)) // 2^248 - 1

	b32Value := BigIntToBytes32(value)
	require.True(t, bytes.Equal(b32Value[:], []byte{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0}))

	newValue := Bytes32ToBigInt(b32Value)
	require.True(t, bytes.Equal(newValue.Bytes(), value.Bytes()))
}

func TestFlatten(t *testing.T) {
	in1 := [][32]byte{[32]byte{}}
	in2 := [][32]byte{[32]byte{0x00}, [32]byte{0x01}}
	in3 := [][32]byte{[32]byte{0x01, 0x02, 0x03}, [32]byte{0x04, 0x05, 0x06}}

	expected1 := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
	expected2 := []byte{
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
	expected3 := []byte{
		0x1, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x4, 0x5, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

	out1 := Flatten(in1)
	require.Equal(t, expected1, out1)

	out2 := Flatten(in2)
	require.Equal(t, expected2, out2)

	out3 := Flatten(in3)
	require.Equal(t, expected3, out3)
}
func TestHashToBN255(t *testing.T) {
	// Inputs for proof generation
	msg := []byte{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

	out := HashToBN255(msg)
	require.Equal(t,
		[32]byte{69, 7, 140, 46, 26, 131, 147, 30, 161, 68, 2, 5, 234, 195, 227, 223, 119, 187, 116, 97, 153, 70, 71, 254, 60, 149, 54, 109, 77, 79, 105, 20},
		out)
}

func BenchmarkHashToBN255(b *testing.B) {
	msgSizedInKB := []int{2, 25, 100, 500}
	for _, size := range msgSizedInKB {
		data := make([]byte, size*1024)
		b.Run(fmt.Sprintf("%dKBytes", size), func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				HashToBN255(data)
			}
		})
	}
}
